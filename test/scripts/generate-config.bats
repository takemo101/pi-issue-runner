#!/usr/bin/env bats
# generate-config.sh のBatsテスト

load '../test_helper'

setup() {
    if [[ -z "${BATS_TEST_TMPDIR:-}" ]]; then
        export BATS_TEST_TMPDIR="$(mktemp -d)"
        export _CLEANUP_TMPDIR=1
    fi
    
    # テスト用ディレクトリを作成
    export TEST_REPO="$BATS_TEST_TMPDIR/test_repo"
    mkdir -p "$TEST_REPO"
    cd "$TEST_REPO"
    git init -q
    git config user.email "test@example.com"
    git config user.name "Test User"
    
    # モック環境のセットアップ
    export MOCK_DIR="${BATS_TEST_TMPDIR}/mocks"
    mkdir -p "$MOCK_DIR"
    
    # PI_COMMANDをモックに設定（AI生成をスキップさせる）
    export PI_COMMAND="$MOCK_DIR/pi"
    cat > "$MOCK_DIR/pi" << 'EOF'
#!/usr/bin/env bash
# Mock pi that fails (forces static fallback)
exit 1
EOF
    chmod +x "$MOCK_DIR/pi"
}

teardown() {
    if [[ "${_CLEANUP_TMPDIR:-}" == "1" && -d "${BATS_TEST_TMPDIR:-}" ]]; then
        rm -rf "$BATS_TEST_TMPDIR"
    fi
}

# ====================
# ヘルプ表示テスト
# ====================

@test "generate-config.sh --help shows usage" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --help
    [ "$status" -eq 0 ]
    [[ "$output" == *"Usage:"* ]]
    [[ "$output" == *"--dry-run"* ]]
    [[ "$output" == *"--force"* ]]
    [[ "$output" == *"--validate"* ]]
    [[ "$output" == *"--no-ai"* ]]
}

@test "generate-config.sh -h shows usage" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" -h
    [ "$status" -eq 0 ]
    [[ "$output" == *"Usage:"* ]]
}

# ====================
# --dry-run テスト
# ====================

@test "generate-config.sh --dry-run outputs to stdout" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    # YAMLコンテンツが標準出力に出力される
    [[ "$output" == *"worktree:"* ]]
    [[ "$output" == *"base_dir:"* ]]
}

@test "generate-config.sh --dry-run does not create file" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    [ ! -f ".pi-runner.yaml" ]
}

@test "generate-config.sh --dry-run includes workflows" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"workflows:"* ]]
    [[ "$output" == *"quick:"* ]]
    [[ "$output" == *"thorough:"* ]]
}

# ====================
# 通常の生成テスト
# ====================

@test "generate-config.sh creates .pi-runner.yaml" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    [ -f ".pi-runner.yaml" ]
}

@test "generate-config.sh generated YAML contains worktree section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    grep -q 'worktree:' ".pi-runner.yaml"
    grep -q 'base_dir:' ".pi-runner.yaml"
}

@test "generate-config.sh generated YAML contains multiplexer section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    grep -q 'multiplexer:' ".pi-runner.yaml"
    grep -q 'type:' ".pi-runner.yaml"
}

@test "generate-config.sh generated YAML does not contain singular workflow section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    # workflow: (単数形) は生成されない（workflows: のみ）
    ! grep -qE '^workflow:' ".pi-runner.yaml"
}

@test "generate-config.sh generated YAML contains workflows section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    grep -q 'workflows:' ".pi-runner.yaml"
}

@test "generate-config.sh generated YAML is valid YAML syntax" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    
    # yq/jq/pythonのいずれかでYAMLをパース可能か確認
    if command -v yq &>/dev/null; then
        run yq eval '.' ".pi-runner.yaml"
        [ "$status" -eq 0 ]
    elif command -v python3 &>/dev/null; then
        run python3 -c "import yaml; yaml.safe_load(open('.pi-runner.yaml'))"
        [ "$status" -eq 0 ]
    else
        skip "yq or python3 not available for YAML validation"
    fi
}

@test "generate-config.sh shows success message" {
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -eq 0 ]
    [[ "$output" == *"生成しました"* ]] || [[ "$output" == *"generated"* ]]
}

# ====================
# --force テスト
# ====================

@test "generate-config.sh fails if .pi-runner.yaml exists without --force" {
    # 既存ファイルを作成
    echo "existing: config" > ".pi-runner.yaml"
    
    run "$PROJECT_ROOT/scripts/generate-config.sh"
    [ "$status" -ne 0 ]
    [[ "$output" == *"既に存在"* ]] || [[ "$output" == *"exists"* ]]
}

@test "generate-config.sh --force overwrites existing file" {
    # 既存ファイルを作成
    echo "existing: config" > ".pi-runner.yaml"
    
    run "$PROJECT_ROOT/scripts/generate-config.sh" --force
    [ "$status" -eq 0 ]
    # ファイルが上書きされている
    grep -q 'worktree:' ".pi-runner.yaml"
}

# ====================
# --no-ai テスト（静的テンプレート）
# ====================

@test "generate-config.sh --no-ai uses static template" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    # 静的テンプレートのコメントが含まれる
    [[ "$output" == *"Generated by: generate-config.sh (static fallback)"* ]] || \
    [[ "$output" == *"pi-issue-runner configuration"* ]]
}

@test "generate-config.sh --no-ai creates valid YAML" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai
    [ "$status" -eq 0 ]
    [ -f ".pi-runner.yaml" ]
    grep -q 'worktree:' ".pi-runner.yaml"
}

# ====================
# -o / --output テスト
# ====================

@test "generate-config.sh -o custom.yaml creates custom file" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" -o custom.yaml
    [ "$status" -eq 0 ]
    [ -f "custom.yaml" ]
    [ ! -f ".pi-runner.yaml" ]
}

@test "generate-config.sh --output custom.yaml creates custom file" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --output custom.yaml
    [ "$status" -eq 0 ]
    [ -f "custom.yaml" ]
}

@test "generate-config.sh -o requires argument" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" -o
    [ "$status" -ne 0 ]
    [[ "$output" == *"requires"* ]]
}

@test "generate-config.sh --output requires argument" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --output
    [ "$status" -ne 0 ]
    [[ "$output" == *"requires"* ]]
}

# ====================
# --validate テスト
# ====================

@test "generate-config.sh --validate checks existing config" {
    # 有効な設定ファイルを作成（スキーマに準拠）
    cat > ".pi-runner.yaml" << 'EOF'
worktree:
  base_dir: ".worktrees"
  copy_files: []
multiplexer:
  type: tmux
  session_prefix: "pi"
workflow:
  steps:
    - implement
    - merge
workflows:
  quick:
    steps:
      - implement
      - merge
EOF

    # バリデーションツールがない環境ではスキップ
    if ! command -v yq &>/dev/null && ! command -v python3 &>/dev/null && \
       ! command -v ajv &>/dev/null && ! command -v check-jsonschema &>/dev/null; then
        skip "No validation tools available"
    fi

    # スキーマファイルが存在しない場合もスキップ
    if [[ ! -f "$PROJECT_ROOT/schemas/pi-runner.schema.json" ]]; then
        skip "Schema file not found"
    fi

    run "$PROJECT_ROOT/scripts/generate-config.sh" --validate
    # 許容される終了コード:
    # 0: 検証成功
    # 1: 検証失敗（CI環境の差異による誤検出を許容）
    # 2: バリデーションツールなし
    [ "$status" -le 2 ]
}

@test "generate-config.sh --validate fails if config not found" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --validate
    [ "$status" -ne 0 ]
    [[ "$output" == *"not found"* ]] || [[ "$output" == *"見つかりません"* ]]
}

# ====================
# エラーハンドリングテスト
# ====================

@test "generate-config.sh fails on unknown option" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --unknown-option
    [ "$status" -ne 0 ]
    [[ "$output" == *"Unknown"* ]]
}

@test "generate-config.sh fails on unexpected argument" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" unexpected-arg
    [ "$status" -ne 0 ]
    [[ "$output" == *"Unexpected"* ]]
}

# ====================
# プロジェクト情報の収集テスト
# ====================

@test "generate-config.sh detects package.json if exists" {
    # package.jsonを作成
    cat > "package.json" << 'EOF'
{
  "name": "test-project",
  "version": "1.0.0"
}
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    # .worktrees/にcopy_filesが設定される可能性がある（package.jsonは設定されない）
}

@test "generate-config.sh detects .env files for copy_files" {
    # .envファイルを作成
    echo "TEST_VAR=value" > ".env"
    
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    # copy_filesセクションに.envが含まれる
    [[ "$output" == *"copy_files:"* ]] && [[ "$output" == *".env"* ]]
}

@test "generate-config.sh includes session_prefix based on repo name" {
    # リポジトリ名を設定
    git config --local remote.origin.url "https://github.com/test/my-project.git"
    
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"session_prefix:"* ]]
}

# ====================
# 並列実行の安定性テスト
# ====================

@test "generate-config.sh can run in parallel" {
    # 複数のディレクトリで同時実行
    local dir1="$BATS_TEST_TMPDIR/parallel1"
    local dir2="$BATS_TEST_TMPDIR/parallel2"
    
    mkdir -p "$dir1" "$dir2"
    (cd "$dir1" && git init -q && "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run > /dev/null) &
    (cd "$dir2" && git init -q && "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run > /dev/null) &
    
    wait
    [ $? -eq 0 ]
}

# ====================
# 複合オプションテスト
# ====================

@test "generate-config.sh --no-ai --dry-run works together" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"worktree:"* ]]
    [ ! -f ".pi-runner.yaml" ]
}

@test "generate-config.sh --no-ai -o custom.yaml --force works together" {
    echo "old" > "custom.yaml"
    
    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai -o custom.yaml --force
    [ "$status" -eq 0 ]
    [ -f "custom.yaml" ]
    grep -q 'worktree:' "custom.yaml"
}

# ====================
# ワークフロー生成の妥当性テスト
# ====================

@test "generate-config.sh includes default workflows" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # 必須のワークフローが含まれる
    [[ "$output" == *"quick:"* ]]
    [[ "$output" == *"thorough:"* ]]
    [[ "$output" == *"docs:"* ]]
}

@test "generate-config.sh quick workflow has minimal steps" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # quickワークフローにはimplementとmergeが含まれる
    [[ "$output" == *"quick:"* ]]
    
    # quick:の後にimplementとmergeがある
    local after_quick
    after_quick=$(echo "$output" | sed -n '/quick:/,/^[a-z]/p')
    [[ "$after_quick" == *"implement"* ]]
    [[ "$after_quick" == *"merge"* ]]
}

@test "generate-config.sh thorough workflow has all steps" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # thoroughワークフローには複数のステップがある
    [[ "$output" == *"thorough:"* ]]
    
    # thorough:の後にplan、implement、mergeがある
    local after_thorough
    after_thorough=$(echo "$output" | sed -n '/thorough:/,/^[a-z]/p')
    [[ "$after_thorough" == *"plan"* ]]
    [[ "$after_thorough" == *"implement"* ]]
    [[ "$after_thorough" == *"merge"* ]]
}

# ====================
# 設定値の妥当性テスト
# ====================

@test "generate-config.sh sets reasonable max_concurrent" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # max_concurrentが設定されている
    [[ "$output" == *"max_concurrent:"* ]]
}

@test "generate-config.sh includes github section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # githubセクションが含まれる
    [[ "$output" == *"github:"* ]]
}

@test "generate-config.sh includes plans section" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --dry-run
    [ "$status" -eq 0 ]
    
    # plansセクションが含まれる
    [[ "$output" == *"plans:"* ]]
}

# ====================
# ゲート検出テスト
# ====================

@test "generate-config.sh detects Node.js test/lint and proposes gates" {
    cat > "package.json" << 'EOF'
{
  "name": "test-project",
  "scripts": {
    "test": "jest",
    "lint": "eslint ."
  }
}
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"npm run lint"* ]]
    [[ "$output" == *"npm test"* ]]
}

@test "generate-config.sh detects Node.js test only (no lint)" {
    cat > "package.json" << 'EOF'
{
  "name": "test-project",
  "scripts": {
    "test": "jest"
  }
}
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"npm test"* ]]
    [[ "$output" != *"npm run lint"* ]]
}

@test "generate-config.sh detects Bash project (shellcheck + bats)" {
    touch ".shellcheckrc"
    mkdir -p scripts
    touch "scripts/example.sh"
    mkdir -p test
    touch "test/example.bats"

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"shellcheck"* ]]
    [[ "$output" == *"bats"* ]]
}

@test "generate-config.sh detects Go project gates" {
    cat > "go.mod" << 'EOF'
module example.com/test
go 1.21
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"go vet ./..."* ]]
    [[ "$output" == *"go test ./..."* ]]
}

@test "generate-config.sh detects Rust project gates" {
    cat > "Cargo.toml" << 'EOF'
[package]
name = "test-project"
version = "0.1.0"
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"cargo clippy"* ]]
    [[ "$output" == *"cargo test"* ]]
}

@test "generate-config.sh detects Python project gates" {
    cat > "pyproject.toml" << 'EOF'
[project]
name = "test-project"

[tool.ruff]
line-length = 88
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"ruff check ."* ]]
    [[ "$output" == *"pytest"* ]]
}

@test "generate-config.sh detects Makefile test/lint targets" {
    cat > "Makefile" << 'EOF'
lint:
	echo "linting"

test:
	echo "testing"
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" == *"gates:"* ]]
    [[ "$output" == *"make lint"* ]]
    [[ "$output" == *"make test"* ]]
}

@test "generate-config.sh no gates when no tools detected" {
    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]
    [[ "$output" != *"gates:"* ]]
}

@test "generate-config.sh gates section has correct YAML format" {
    cat > "Cargo.toml" << 'EOF'
[package]
name = "test-project"
version = "0.1.0"
EOF

    run "$PROJECT_ROOT/scripts/generate-config.sh" --no-ai --dry-run
    [ "$status" -eq 0 ]

    # Verify gates entries are properly indented YAML list items
    echo "$output" | grep -qE '^gates:$'
    echo "$output" | grep -qE '^  - "cargo clippy"$'
    echo "$output" | grep -qE '^  - "cargo test"$'
}
