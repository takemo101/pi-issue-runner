# Pi Issue Runner - 設計思想と価値

## なぜこの仕組みが重要なのか

Pi Issue Runnerは、**AIエージェントによる並列開発**を実現するための基盤ツールです。

### 解決する課題

従来のAIコーディングアシスタントには以下の制約がありました：

| 課題 | 従来のアプローチ | Pi Issue Runnerの解決策 |
|------|------------------|------------------------|
| **シングルコンテキスト** | 1つのタスクに1つのエージェント | 複数Issueを独立した環境で並列処理 |
| **環境の干渉** | 同じディレクトリで作業、コンフリクト発生 | Git worktreeによる完全分離 |
| **待機時間のロス** | AIの応答を待つ間、他の作業ができない | バックグラウンド実行、複数タスク同時進行 |
| **コンテキストの切り替え** | 手動でブランチを切り替え、状態を管理 | セッション単位で自動管理 |

### 核心的な価値

```
┌─────────────────────────────────────────────────────────────────┐
│                    並列AIエージェント開発                        │
│                                                                  │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐     │
│   │Issue #1 │    │Issue #2 │    │Issue #3 │    │Issue #N │     │
│   │  (bug)  │    │(feature)│    │ (docs)  │    │  (...)  │     │
│   └────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘     │
│        │              │              │              │           │
│   ┌────▼────┐    ┌────▼────┐    ┌────▼────┐    ┌────▼────┐     │
│   │worktree │    │worktree │    │worktree │    │worktree │     │
│   │   + pi  │    │   + pi  │    │   + pi  │    │   + pi  │     │
│   └────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘     │
│        │              │              │              │           │
│        ▼              ▼              ▼              ▼           │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                 自動PR作成 → マージ                      │  │
│   └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## 設計原則

### 1. 完全な分離（Isolation）

各タスクは以下のリソースを独立して持ちます：

- **Git worktree**: ファイルシステムレベルで分離
- **マルチプレクサセッション（tmux/Zellij）**: プロセスレベルで分離
- **Piインスタンス**: AIコンテキストレベルで分離
- **ステータスファイル**: 状態管理レベルで分離

### 2. GitHub Issue中心（Issue-Driven）

```
GitHub Issue = Single Source of Truth
       │
       ├── Issue番号 → ブランチ名生成
       ├── Issueタイトル → コンテキスト提供
       ├── Issue本文 → タスク定義
       └── Issueラベル → メタデータ
```

GitHub Issueを起点とすることで：
- タスクの追跡可能性（traceability）
- 自然なPR連携（Closes #xxx）
- チーム間の可視性

### 3. 自動クリーンアップ（Zero Overhead）

```
タスク完了 → マーカー検出 → 自動クリーンアップ
                              │
                              ├── worktree削除
                              ├── セッション終了
                              └── ステータス更新
```

手動でのリソース管理を不要にし、次のタスクに集中できる環境を提供。

### 4. 拡張可能なワークフロー（Extensible Workflow）

```yaml
# シンプルなタスク
steps:
  - implement
  - merge

# 厳密なタスク
steps:
  - plan
  - implement
  - test
  - review
  - merge
```

プロジェクトやタスクの性質に応じてワークフローをカスタマイズ可能。

## 主要機能

### 1. 品質ゲート（run: ステップ）

ワークフローの任意の位置にシェルコマンド実行（`run:`）を挿入できます。
AIステップの間に ShellCheck やテスト実行を挟むことで、マージ前の品質を担保します。
実行結果は `.pi/run-outputs/` にファイル保存され、後続のAIステップから参照可能です。

詳細は [workflows.md](workflows.md#run-ステップ非aiステップ) を参照。

### 2. コードレビュー

通常のAIステップ（`review` 等）としてメインセッション内で実行します。
実装コンテキストを保持したままレビューできるため、的確な指摘が可能です。
並列レビューが必要な場合は、AIエージェント自身のサブエージェント機能を使用できます。

## ユースケース

### 1. 並列バグ修正

```bash
# 3つのバグを同時に修正
./scripts/run.sh 101 --no-attach  # Critical bug
./scripts/run.sh 102 --no-attach  # UI glitch
./scripts/run.sh 103 --no-attach  # Performance issue

# 全て完了するまで待機
./scripts/wait-for-sessions.sh 101 102 103
```

### 2. 継続的改善サイクル

```bash
# プロジェクトを自動分析→Issue作成→修正→検証
./scripts/improve.sh --max-iterations 3
```

### 3. 大規模リファクタリング

```bash
# 親Issueを分解
decompose-issue 200  # → #201, #202, #203 を自動作成

# 依存関係を考慮して順次実行
./scripts/run.sh 201 --no-attach
./scripts/wait-for-sessions.sh 201
./scripts/run.sh 202 --no-attach
./scripts/run.sh 203 --no-attach
```

## アーキテクチャの進化

### Phase 1: 基盤構築 ✅

- Git worktree管理
- マルチプレクサセッション管理（tmux/Zellij）
- 基本的な並列実行
- ステータス管理

### Phase 2: 自動化強化 ✅

- 自動クリーンアップ（watch-session.sh）
- ワークフローエンジン
- Hook機能
- 継続的改善（improve.sh）

### Phase 3: 堅牢性向上 ✅

- ✅ セキュリティ強化（サニタイズ）
- ✅ エラーハンドリング改善
- ✅ テストカバレッジ向上（1000+ tests）
- ✅ ドキュメント整備

### Phase 4: 将来の拡張（進行中）

- ⏳ CI/CD統合（部分実装）
  - ✅ CI失敗自動検出・修正
  - ✅ CI状態監視
  - ⏳ GitHub Actions統合
- ⏳ Webhookサポート（計画中）
- ⏳ Webダッシュボード（計画中）
- ⏳ マルチリポジトリ対応（計画中）

## 技術的決定とトレードオフ

### なぜシェルスクリプトか

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| **シェルスクリプト（採用）** | 依存なし、どこでも動く、Unix哲学 | 複雑なロジックが書きにくい |
| TypeScript/Node.js | 型安全、豊富なエコシステム | Node.jsが必要、起動が遅い |
| Python | 読みやすい、ライブラリ豊富 | Python環境が必要 |

**決定理由**: piスキルとして最大の互換性を持ち、追加依存なしで動作させるため。

### マルチプレクサの選択（Tmux/Zellij）

Pi Issue Runnerは **tmux** と **Zellij** の両方をサポートしており、設定で切り替えることができます。

| マルチプレクサ | メリット | デメリット | 推奨用途 |
|---------------|----------|------------|----------|
| **Tmux（デフォルト）** | 安定、広く利用、出力キャプチャ可能 | 設定がやや複雑 | 本番環境、CI/CD、安定性重視 |
| **Zellij** | モダン、設定が簡単、直感的なUI | まだ普及途上、tmuxより新しい | ローカル開発、UX重視 |
| Screen | 古くからある、安定 | 機能が限定的 | *サポート対象外* |
| バックグラウンドプロセス | 依存なし | 出力確認が困難、アタッチ不可 | *サポート対象外* |

**採用理由**: 
- セッション管理とバックグラウンド実行の柔軟性
- 出力キャプチャとリアルタイム監視の両立
- いつでもアタッチ/デタッチできる運用性
- 抽象化レイヤーにより複数のマルチプレクサをサポート

### なぜGit Worktreeか

| 選択肢 | メリット | デメリット |
|--------|----------|------------|
| **Git Worktree（採用）** | オブジェクト共有、軽量、高速 | Git 2.17+が必要 |
| Clone | 完全分離 | ディスク消費大、遅い |
| ブランチ切り替え | シンプル | 並列不可、コンフリクト |

**決定理由**: 並列作業を可能にしつつ、ディスク使用量と作成時間を最小化するため。

## ベストプラクティス

### 推奨される使い方

1. **小さなIssueに分解**: 1Issue = 1機能/1バグ修正
2. **バックグラウンド実行**: `--no-attach` で起動
3. **定期的な状態確認**: `list.sh` でセッション確認
4. **完了後は素早くレビュー**: 自動マージ前にPR確認

### アンチパターン

1. ❌ 巨大なIssueを1つのセッションで処理
2. ❌ `max_concurrent` を無制限にしてリソース枯渇
3. ❌ クリーンアップせずにworktreeを放置
4. ❌ ステータス確認なしで結果を信頼

## 関連ドキュメント

- [SPECIFICATION.md](./SPECIFICATION.md) - 詳細仕様
- [architecture.md](./architecture.md) - システム構成
- [parallel-execution.md](./parallel-execution.md) - 並列実行の詳細
- [workflows.md](./workflows.md) - ワークフローカスタマイズ
